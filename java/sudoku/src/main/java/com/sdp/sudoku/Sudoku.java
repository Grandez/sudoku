/*
 * This source file was generated by the Gradle 'init' task
 */
package com.sdp.sudoku;

import com.sdp.sudoku.ctes.CDG;
import com.sdp.sudoku.io.*;
import com.sdp.sudoku.boards.*;

import java.util.ArrayList;
import java.util.List;

public class Sudoku {
    Board board;
    Output out = Output.getInstance();
    int ntree = 0;
    StringBuilder stree = new StringBuilder("1 ");

    public int playGame(Integer[] data) {
        Board board = prepareBoard(data);
        return play(board, 0);
    }
    public Board getBoard() {
        return board;
    }
    private int play (Board board, int tree) {
        Board pBoard = null;
        int rc = CDG.NEXT;
        while (rc == CDG.NEXT) {
            List<Square> options = board.getCandidates();
            if (options.size() == 0) return CDG.DONE;
            switch (options.get(0).cardinal2()) {
                case 0: rc = CDG.FAIL; break;
                case 1: rc = processEquivalentBoard(board, options); break;
                default:
                    pBoard = board.copy();
                    List<Square> copyList = new ArrayList<>(options);
                    pBoard.setTree(ntree);

                    for (int i = 0; i < copyList.get(0).cardinal2(); i++) {
                        Board iboard = pBoard.copy();
                        iboard.bet(i);  // Ponemos el valor como unica opcion
                        if (play(iboard, iboard.getTree()) == CDG.DONE) return CDG.DONE;
                    }
                    rc = CDG.FAIL;
            }
        }
        return rc;
    }
    private int processEquivalentBoard(Board board, List<Square> options) {
        for (Square square : options) square.setPlaying();
        return board.round(null);
    }
    private Board prepareBoard(Integer[] data) {
        BoardFactory factory = new BoardFactory();
        Board board = factory.getBoard(data);
        board.init();
        return board;
    }
}
